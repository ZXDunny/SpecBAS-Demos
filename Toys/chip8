ZXASCII
AUTO -1
PROG demos:toys/chip8
CHANGED FALSE
10 rem Chip-8 Interpreter

20 option "BASE",0:
 dim ram(4096);regs(16);disp(64,32);keys(16);
     k=key_x,key_1,key_2,key_3,
       key_q,key_w,key_e,key_a,
       key_s,key_d,key_z,key_c,
       key_4,key_r,key_f,key_v:
 pc,i,timer,stimer,df,ks=0,stack$="",rs=10*scrw/800,
 xo=(scrw-64*rs)/2,yo=(scrh-32*rs)/2

30 for n=80 to 159:
    read ram(n):
 next n:
 data $F0,$90,$90,$90,$F0,$20,$60,$20,$20,$70,$F0,$10,$F0,$80,$F0,$F0,$10,$F0,$10,$F0,
      $90,$90,$F0,$10,$10,$F0,$80,$F0,$10,$F0,$F0,$80,$F0,$90,$F0,$F0,$10,$20,$40,$40,
      $F0,$90,$F0,$90,$F0,$F0,$90,$F0,$10,$F0,$F0,$90,$F0,$90,$90,$E0,$90,$E0,$90,$E0,
      $F0,$80,$80,$80,$F0,$E0,$90,$90,$90,$E0,$F0,$80,$F0,$80,$F0,$F0,$80,$F0,$80,$80

40 paper 230: palette 1,$FFFFFF: cls: screen lock:
 GO SUb 4000:
 pc=512,cc=-1

50 rem Main loop

60 GO SUb 3000:
 do 500:
    cil=ram(pc & 4095),pc+=1,
    ci=cil*256+ram(pc & 4095),pc+=1:
    v=ci shr 12,
    x=ci shr 8 & 15,y=ci shr 4 & 15,
    n=ci & 15,nn=ci & 255,nnn=ci & 4095:
    GO SUb 1000+v*100:
 loop

70 rem end of frame

80 timer-=timer>0,stimer-=stimer>0:
 if stimer>0 then beep 1/60,0 async
90 IF df THEN GO SUb 5000
100 WAIT SCREEN:
 GO TO 50

900 rem Opcode handlers. Do not RENUMBER beyond this point!

1010 if ci=$E0 then clear disp(): df=1
1020 if ci=$EE then pc=DCODE stack$(1 to 2): stack$=stack$(3 to )
1099 return

1100 pc=nnn:
 return
1200 stack$=dchr$ pc+stack$:
 pc=nnn:
 return

1300 if regs(x)=nn then pc+=2
1390 return

1400 if regs(x)<>nn then pc+=2
1490 return

1500 if regs(x)=regs(y) then pc+=2
1590 return

1600 regs(x)=nn:
 return

1700 regs(x)=regs(x)+nn & 255:
 return

1800 GO To 1801+n: rem 8XYn

1801 regs(x)=regs(y):
 return

1802 regs(x)=regs(x) | regs(y),
 regs(15)=0:
 return

1803 regs(x)=regs(x) & regs(y),
 regs(15)=0:
 return

1804 regs(x)=regs(x) xor regs(y),
 regs(15)=0:
 return

1805 regs(x)=regs(x)+regs(y),
 regs(15)=regs(x)>255,
 regs(x)&=255:
 return

1806 fl=regs(x)>=regs(y),
 regs(x)-=regs(y),
 regs(x)&=255,
 regs(15)=fl:
 return

1807 fl=regs(y) & 1,
 regs(x)=regs(y) shr 1,
 regs(15)=fl:
 return

1808 fl=regs(y)>=regs(x),
 regs(x)=(regs(y)-regs(x))&255,
 regs(15)=fl:
 return

1815 fl=(regs(y) & 128)>0,
 regs(x)=regs(y) shL 1 & 255,
 regs(15)=fl:
 return

1900 if regs(x)<>regs(y) then pc+=2
1990 return

2000 i=nnn: return

2100 pc=nnn+regs(0):
 return

2200 regs(x)=int(rnd*255) & nn:
 return

2300 timer-=timer>0,
 df=1,
 cx=regs(x) & 63,
 cy=regs(y) & 31,fl=0:
 for a=0 to min(n-1,31-cy):
    db=ram((i+a) & 4095),bt=256:
    for dx=cx to min(cx+7,63):
       j=db&(bt/=2)>0,
       fl|=j and disp(dx,cy),
       disp(dx,cy)~=j:
    next dx:
    cy+=1:
 next a:
 regs(15)=fl:
 return

2400 pc+=2*(keys(regs(x)&15)<>IIF(nn=158,0,1)):
 RETURn

2500 GO To 2501+nn

2508 regs(x)=timer:
 return

2511 pc-=2:
 if ks=0 then ks=1
2512 if ks=1 then
    for f=0 to 15:
       if keys(f) then
          regs(x)=f:
          ks=2
       end if:
    next f:
    return
2513 if ks=2 and keys(regs(x))=0 then
    ks=0:
    pc+=2
2520 return

2522 timer=regs(x):
 return

2525 stimer=regs(x):
 return

2531 i+=regs(x)&4095:
 return

2542 i=$50+(regs(x) & 15)*5:
 return

2552 a$=lpad$(str$(regs(x) & 255),"0",3),
 ram(i & 4095)=val a$(1),
 ram((i+1) & 4095)=val a$(2),
 ram((i+2) & 4095)=val a$(3):
 return

2586 for n=0 to x:
    ram((i+n) & 4095)=regs(n):
 next n:
 i+=x-1:
 return

2602 for n=0 to x:
    regs(n)=ram((i+n) & 4095):
 next n:
 i+=x-1:
 return

2999 rem Keyboard scanning

3000 for f=0 to 15:
    keys(f)=keyst k(f):
 next f:
 return

4000 rem load a ROM
4001 load "" bank new rom
4020 for f=0 to banklen rom-1:
    ram(512+f)=peek(rom,f):
 next f:
 return

4999 rem Update display

5000 for xx=0 to 63:
    for yy=0 to 31:
       rectangle ink disp(xx,yy);xx*rs+xo,yy*rs+yo,rs-1,rs-1 fill:
    next yy:
 next xx:
 df=1:
 return
